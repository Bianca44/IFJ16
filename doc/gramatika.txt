<class-list> -> class ID { <class-elements> } <class-list>
<class-elements> -> static <data-type> ID = E; <class-elements>
<class-elements> -> static <return-type> ID ( <param-list> ) { <method-elements> } <class-elements>

<literal> -> INT_LITERAL
<literal> -> DOUBLE_LITERAL
<literal> -> STRING_LITERAL

<data-type> -> int 
<data-type> -> double
<data-type> -> String
<data-type> -> boolean

<return-type> -> void
<return-type> -> int 
<return-type> -> double
<return-type> -> String
<return-type> -> boolean

<param-list> -> epsilon
<param-list> -> <param> , <param-list>
<param> -> <data-type> ID = E; 
<param> -> <data-type> ID = <literal>

<method-elements> -> epsilon
<method-elements> -> <statement-list> <method-elements>
<method-elements> -> if <E> <condition-statement> else <condition-statement>; <method-elements>
<method-elements> -> if <E> <condition-statement>; <method-elements>
<method-elements> -> while <E> <condition-statement>;
<method-elements> -> return <E>;


<condition-statement> -> { <statement-list> } <condition-statement>
<condition-statement> -> <statement>
<statement-list> -> <statement>; <statement-list>
<statement> -> ID = <E>; <statement>
<statement> -> <data-type> ID = E; <statement>
<statement> -> <method>; <statement>


//pravidla pre precedencnu analyzu
<E> -> <literal>
<E> -> ! <E>
<E> -> <E> <op> <E>
<E> -> (E)
<E> -> <method>
<method> -> ID (<param-list>);

<op> -> ADD
<op> -> SUB
<op> -> DIV
<op> -> MUL
<op> -> LOGICAL_AND
<op> -> LOGICAL_OR
